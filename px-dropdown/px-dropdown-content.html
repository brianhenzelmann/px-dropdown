<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
-->
<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../px-tooltip/px-tooltip.html" />
<!--
Element providing the content for the px-dropdown element

##### Usage

    <px-dropdown-content class="px-dropdown-content" extend-dropdown="true" extend-dropdown-by="40" items='[{"key":"one", "val": "One"}, {"key":"two", "val": "Two"}]'>

@element px-dropdown-content
@blurb Element to contain contents of a dropdown menu.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-dropdown-content">
  <link rel="import" type="css" href="css/px-dropdown-content.css" />
  <template>
      <div class="px-dropdown--content" id="dropdown" hidden$="{{!menuOpen}}">
        <ul class="px-dropdown--list list-bare">
          <template is="dom-repeat" items={{computedItems}}>
            <li class="px-dropdown--listitem u-p--" on-tap="_clickItem">{{item.val}}
              <template is="dom-if" if="{{_includeTooltip(item.val)}}">
                  <px-tooltip tooltip-message="{{item.val}}"></px-tooltip>
              </template>
            </li>
          </template>
      </div>
  </template>
</dom-module>
<script>
  Polymer({

    is: 'px-dropdown-content',

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * Array that contains the list of items which show up in the dropdown
       *
       * @type Array
       * @default []
       */
      items: {
        type: Array,
        notify: true,
        value: function() {
          return [];
        }
      },
      /**
       * This property stores the items array, after it's been
       * changed over to be an array of objects.
       *
       * @type Array
       * @default []
       */
      computedItems: {
        type: Array,
        value: function() {return [];},
        computed: '_computedItems(items)'
      },
      /**
       * The initial selected value (if any) of an item in the dropdown
       * @type String
       * @default ''
       * @notify true
       */
      selectedValue: {
        type: String,
        notify: true,
        value: '',
        observer: '_updateSelectedItem'
      },
      /**
       * Used to check if the dropdown is currently open or closed.
       * notifies and shows/hides the dropdown.
       * @type Boolean
       * @default false
       */
      menuOpen: {
        type: Boolean,
        notify: true,
        value: false
      },
      /**
       * Maximum number of characters in a container.
       * Will be used to calculate whether the dropdown will have a tooltip and ellipsis.
       * Optional.
       * @type Number
       * @default
       */
      maxContCharacterWidth: {
        type: Number,
        value: 0
      },
      /**
       * An attribute which specifies if the dropdown should extend in width
       * beyond the cell it's dropping from.
       * Optional.
       * @type Boolean
       * @default: false
       */
      extendDropdown: {
        type: Boolean,
        value: false,
      },
      /**
       * An attribute which specifies how many pixels the dropdown
       * should extend beyond the cell it's dropping from.
       * Optional.
       * @type Number
       * @default: 15
       */
      extendDropdownBy: {
        type: Number,
        value: 15,
      },
      /**
       * An attribute which specifies whether the dropdown is
       * extended in width from its container.
       * @type Boolean
       * @default: false
       */
      extended : {
        type: Boolean,
        value: false
      },
      /**
       * An attribute which specifies whether the dropdown has been opened at
       * least once
       * @type Boolean
       * @default: false
       */
      _hasBeenOpened : {
        type: Boolean,
        value: false
      }
    },
    attached: function() {
      if (this.maxContCharacterWidth > 0) {
        this._fireMaxChar();
      }
    },
    /**
     * Fire an event that has a maxContCharacterWidth into px-text
     *
     * @method _fireMaxChar
     */
    _fireMaxChar: function() {
      var parent = this.parentNode,
          px_text = Polymer.dom(parent).querySelector('px-dropdown-text');
      px_text.fire('maxContCharacterWidth', {maxContCharacterWidth : this.maxContCharacterWidth});
    },
    /**
     * Opens the dropdown menu
     *
     * @method open
     */
    open: function() {
      this.menuOpen = true;

      if(!this._hasBeenOpened) {

        //do first adjustments we wont need ot do in the future
        this.adjustHeight();
        this._extendDropdown();
      }
      this.set('_hasBeenOpened', true);
    },
    /**
     * Closes the dropdown menu
     *
     * @method close
     */
    close: function() {
      this.menuOpen = false;
    },
    /**
     * size the content to height to fit maxHeight and do the height adjustments
     * for scrolling
     *
     * @method sizeHeight
     * @param maxHeight
     */
    sizeHeight: function(maxHeight) {
      var currentHeight = parseInt(this.$.dropdown.getBoundingClientRect().height);

      //limit height
      if(currentHeight > maxHeight) {
        this.$.dropdown.style.height = maxHeight + 'px';
      }
      else {
        this.adjustHeight();
      }
    },
    /**
     * reset the height of the content
     *
     * @method resetHeight
     */
    resetHeight: function() {
      this.$.dropdown.style.height = '';
    },
    /**
     * Checks if the length of the value in the dropdown list is longer than
     * the allowed Max length, passed in as maxContCharacterWidth.
     * If it is, px-tooltip is included with the component.
     *
     * @method _includeTooltip
     * @param value
     */
    _includeTooltip: function(value) {
      //find the container max character passed in
      var maxContWidth = this.maxContCharacterWidth;
      if(value === null || value === undefined || typeof value === 'string' && value.trim().length === 0) {
        return false;
      }
      //find out if the character count in the passed value is higher than the allowed max. if it is, we show the tooltip.
      return (maxContWidth !== undefined && maxContWidth !== null && maxContWidth !== 0) ? (value.length > maxContWidth) : false;
    },
    /**
     * This function is called on an item click, and calls the fire event
     * as well as closes the dropdown. Finally, it flips the opened flag.
     *
     * @method _clickItem
     */
    _clickItem: function(evt) {
      this._clickFire(evt);
      this.close();
      this.fire('dropdown_flip', true);
      this.set('selectedValue', evt.target.firstChild.textContent);
    },
    /**
     * This fires a notification that happens on click, allowing the evt to be
     * picked up by an external developer.
     *
     * @method _clickFire
     */
    _clickFire: function(evt) {
      this.fire('px-dropdown-click', evt);
    },
    /**
     * This allows for the dropdown to be extended to make sure it's more distinguishable
     * from its container.
     *
     * @method _extendDropdown
     */
    _extendDropdown: function() {
      if (!this.extended && this.extendDropdown) {
        //get the width of the dropcell, and how much to extend it by.
        var parent = this.parentNode,
            dropcell = parent.$.dropcell,
            width = dropcell.getBoundingClientRect().width,
            extendBy = this.extendDropdownBy;
        //set the flag that we've extended the dropdown. without this, it'll keep extending.
        this.extended = true;
        this.$.dropdown.style.width = parseInt(width) + parseInt(extendBy) + 'px';
      }
    },
    /**
     * This allows for the dropdown height to be adjusted by reducing it by half
     * an item's height if the dropdown has scrollbars so it's more obvious we
     * can scroll
     * @method adjustHeight
     */
    adjustHeight: function() {
      var currentHeight = parseInt(this.$.dropdown.getBoundingClientRect().height);

      //do we have a scrollbar?
      if(currentHeight < this.$.dropdown.scrollHeight) {

        //reduce height by half the size of an item
        var parent = this.parentNode,
            dropcell = parent.$.dropcell,
            reduceBy = parseInt(dropcell.getBoundingClientRect().height/2);

        this.$.dropdown.style.height = currentHeight - reduceBy + 'px';
      }
    },
    /**
     * This function finds out whether the passed items array is
     * an array of objects, or an array of strings. if it is strings
     * they are converted to objects.
     * @method _computedItems
     * @param items (Array)
     */
    _computedItems: function(items) {
      if (typeof this.items[0] === 'string') {
        var len = items.length,
            i = 0,
            computedItemsArr = [];

            for (i; i < len; i++) {
              computedItemsArr.push({val:items[i]});
            }
            return computedItemsArr;
      } else {
        return this.items;
      }
    },
    /**
     * This function updates the displayed text on the visible portion of the closed dropdown.
     * @method _updateSelectedItem
     *
     */
    _updateSelectedItem: function() {
      var parent = this.parentNode,
          text = Polymer.dom(parent).querySelector('px-dropdown-text');
          if (text && this.selectedValue) {
            text.set('displayValue', this.selectedValue);
          }
        }
  });
</script>
